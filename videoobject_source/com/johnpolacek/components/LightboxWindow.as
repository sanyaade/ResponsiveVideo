package com.johnpolacek.components {	import flash.display.BlendMode;	import flash.display.Shape;	import flash.display.Sprite;	import flash.display.StageDisplayState;	import flash.text.AntiAliasType;	import flash.text.Font;	import flash.text.TextFormat;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.filters.BitmapFilter;	import flash.filters.BitmapFilterQuality;	import flash.filters.DropShadowFilter;	import flash.ui.Keyboard;	import com.greensock.TweenLite;	import com.greensock.easing.Expo;	import com.johnpolacek.components.LightboxContentInfo;	import com.johnpolacek.components.LightboxFormat;	import com.johnpolacek.display.AudioDisplay;	import com.johnpolacek.display.ContentDisplay;	import com.johnpolacek.display.ContentDisplayCreator;	import com.johnpolacek.display.VideoDisplay;	import com.johnpolacek.events.UIEvent;	import com.johnpolacek.shapes.ArrowHead;	import com.johnpolacek.shapes.EllipseShape;	import com.johnpolacek.shapes.RectangleShape;	import com.johnpolacek.utils.DisplayUtils;/** * The LightboxWindow class contains the ContentDisplay sprite.  * Uses the ContentDisplayCreator simple Factory to generate content containers *  * @sends new Event(LIGHTBOX_PREV) # When prevButton is clicked.  * @sends new Event(LIGHTBOX_NEXT) # When prevButton is clicked.  * * @see com.johnpolacek.display.ContentDisplayCreator * @see com.johnpolacek.display.ContentDisplay * @author John Polacek, john@johnpolacek.com */	 	public class LightboxWindow extends Sprite 	{		/**  Event constant for transitioning to next ContentDisplay in the content group **/		public static const LIGHTBOX_NEXT:String = "lightboxNext";		/**  Event constant for transitioning to prev ContentDisplay in the content group **/		public static const LIGHTBOX_PREV:String = "lightboxPrev";		/**  Constant for build transitionStyle **/		public static const TRANSITION_BUILD = "transitionBuild";		/**  Constant for fly in right transitionStyle  **/		public static const TRANSITION_FLY_IN_RIGHT = "transitionFlyInRight";		/**  Constant for fly in left transitionStyle  **/		public static const TRANSITION_FLY_IN_LEFT = "transitionFlyInLeft";		/**  Determines which style is used for transitions in and out  **/		public var transitionStyle:String = TRANSITION_BUILD;		/**  The content info object corresponding to the content in the window  **/		public var contentInfo:LightboxContentInfo;		/**  Maximum width of content, in pixels.  **/		public var maxContentWidth:int = 9999;		/**  Maximum height of content, in pixels.  **/		public var maxContentHeight:int = 9999;				// Display Objects		private var contentBackground:Sprite;		private var descriptionText:Sprite;				private var content:ContentDisplay;		private var closeButton:Sprite;		private var nextButton:Sprite;		private var prevButton:Sprite;		private var navButtonField:TextField		private var contentCreator:ContentDisplayCreator;		private var format:LightboxFormat;		private var currElement:int = 0;		private var totalElements:int = 0;						/** 		* @param f The LightboxFormat object that holds all styling info. If null, default styling is used.		**/		public function LightboxWindow (f:LightboxFormat = null) 		{			format = f ? f : new LightboxFormat(); 			this.blendMode = BlendMode.LAYER;			contentCreator = new ContentDisplayCreator();  // Simple Factory class that returns ContentDisplay sprite			contentCreator.playerBackgroundColor = format.playerBackgroundColor;			contentCreator.playerButtonColor = format.playerButtonColor;			contentCreator.playerAccentColor = format.playerAccentColor;			this.visible = false;			addEventListener(UIEvent.FULL_SCREEN_CONTENT, onFullScreenContent);			trace("format.enableKeyboardControls "+format.enableKeyboardControls);		}				/** 		* Loads and displays content.		* @param contentURL Filepath to the content		* @param tText Text that will appear in the title field of the content window. Default is ""		* @param stText Text that will appear in the subtitle field of the content window. Default is ""		* @param nText Text that will appear in the note field of the content window. Default is ""		* @param contentInfo Object that holds additional values for content. Default is null		**/		public function displayContent(c:LightboxContentInfo):void		{			contentInfo = c;			content = contentCreator.create(contentInfo.url, contentInfo);			content.addEventListener(Event.COMPLETE, onContentLoadComplete, false, 0, true);			content.addEventListener(IOErrorEvent.IO_ERROR, onIOError, false, 0, true);						if (!content) 				trace("Error: Could not initialize content:"+contentInfo.url);						descriptionText = createDescriptionText();		}				/**  Initiates content window close transition. **/		public function close():void		{			transitionOut();			if (stage.hasEventListener(KeyboardEvent.KEY_DOWN))				stage.removeEventListener(KeyboardEvent.KEY_DOWN, onKeyboard);			content.removeEventListener(Event.COMPLETE, onContentLoadComplete);		}		//--------------------------------------------------------------------------    //    //  Object Creation    //    //--------------------------------------------------------------------------			private function build():void		{			trace("LightboxWindow.build");			trace("format.videoAutoPlay "+format.videoAutoPlay);			if (content is VideoDisplay)			{				var video:VideoDisplay = content as VideoDisplay;				video.player.enableFullScreen(format.videoFullScreen);				if (!format.videoAutoPlay) {					video.player.rewindVideo();				}							}			var maxWindowHeight:int = maxContentHeight - descriptionText.height - (format.buttonSize * 3);			if (content.height > maxContentHeight || content.width > maxContentWidth)				DisplayUtils.scaleToFit(content, maxContentWidth, maxWindowHeight);			contentBackground = createBackground();			content.x = -content.width/2;			content.y = -content.height/2;			descriptionText.x = -contentBackground.width/2;			descriptionText.y = -contentBackground.height/2 - descriptionText.height - 6;			closeButton = createCloseButton();			closeButton.x = contentBackground.width/2 - closeButton.width;			closeButton.y = contentBackground.height/2 + 6;			closeButton.addEventListener(MouseEvent.CLICK, onCloseClick, false, 0, true);			addChild(contentBackground);			addChild(descriptionText);			addChild(content);			addChild(closeButton);			if (contentInfo.linkText != "")			{				var linkTextField:TextField = createLinkText();				linkTextField.x = content.x + content.width - linkTextField.textWidth - 4;				linkTextField.y = content.y + content.height - linkTextField.textHeight - 4;				addChild(linkTextField);			}			if (currElement > 0 && totalElements > 0)			{				navButtonField = new TextField();				var navButtonFormat:TextFormat = format.navTextFormat;				navButtonField.antiAliasType = AntiAliasType.ADVANCED;				navButtonField.autoSize = TextFieldAutoSize.LEFT;				navButtonField.text = currElement + " of " + totalElements;				navButtonField.x = content.x - format.margin;				navButtonField.y = closeButton.y;				if (format.subtitleTextFormat.font != null) 					navButtonField.embedFonts = true;				navButtonField.setTextFormat(navButtonFormat);				navButtonField.blendMode = BlendMode.LAYER;				addChild(navButtonField);								prevButton = createNavButton();				prevButton.scaleX = -1;				prevButton.x = (contentBackground.width - format.buttonSize*6)/2;				prevButton.y = closeButton.y;				addChild(prevButton);								nextButton = createNavButton();				nextButton.x = (contentBackground.width - format.buttonSize*5)/2;				nextButton.y = closeButton.y;				addChild(nextButton);								nextButton.addEventListener(MouseEvent.CLICK, onNextClick, false, 0, true);				prevButton.addEventListener(MouseEvent.CLICK, onPrevClick, false, 0, true);			}						// If content is audio play, start playback of top audio track			if (content is AudioDisplay)			{				AudioDisplay(content).menu.selectPlayer(0);				AudioDisplay(content).menu.players[0].autoPlay = true;			}						transitionIn();		}				private function createDescriptionText():Sprite		{			var sprite:Sprite = new Sprite();			if (contentInfo.title != "")			{				var titleField:TextField = new TextField();				titleField.autoSize = TextFieldAutoSize.LEFT;				titleField.text = contentInfo.title;				if (format.titleTextFormat.font != null) 					titleField.embedFonts = true;				titleField.setTextFormat(format.titleTextFormat);				titleField.width = content.width;				titleField.y = 4;				sprite.addChild(titleField);			}			if (contentInfo.subtitle != "")			{				var subtitleField:TextField = new TextField();				subtitleField.antiAliasType = AntiAliasType.ADVANCED;				subtitleField.autoSize = TextFieldAutoSize.LEFT;				subtitleField.text = contentInfo.subtitle;				subtitleField.y = sprite.height + 2;				if (format.subtitleTextFormat.font != null) 					subtitleField.embedFonts = true;				subtitleField.setTextFormat(format.subtitleTextFormat);				subtitleField.width = content.width;				sprite.addChild(subtitleField);			}			if (contentInfo.note != "")			{				var noteField:TextField = new TextField();				noteField.antiAliasType = AntiAliasType.ADVANCED;				noteField.autoSize = TextFieldAutoSize.LEFT;				noteField.text = contentInfo.note;				noteField.y = sprite.height + 3;				if (format.noteTextFormat.font != null) 					noteField.embedFonts = true;				noteField.setTextFormat(format.noteTextFormat);				noteField.width = content.width;				sprite.addChild(noteField);			}			return sprite;		}				private function createLinkText():TextField		{			var linkField:TextField = new TextField();			linkField.antiAliasType = AntiAliasType.ADVANCED;			linkField.autoSize = TextFieldAutoSize.LEFT;			linkField.text = contentInfo.linkText;			if (format.linkTextFormat.font != null) 				linkField.embedFonts = true;			linkField.setTextFormat(format.linkTextFormat);			linkField.width = content.width;			return linkField;		}				private function createBackground():Sprite		{			var bgr:Sprite = new RectangleShape(content.width + format.margin*2, 												content.height + format.margin*2, 												format.contentBackgroundColor, 												format.contentBackgroundAlpha, 												0, 0, 0, true);			var dropShadow:BitmapFilter = new DropShadowFilter(2, 90, 0x000000, format.dropShadowAlpha, 12, 12, 1, BitmapFilterQuality.MEDIUM);			bgr.filters = [dropShadow];			return bgr;		}				private function createCloseButton():Sprite		{			var btn:Sprite = new Sprite();			var btnBgr:Sprite = new EllipseShape(format.buttonSize, format.buttonSize, format.accentColor);			var line1:Shape = new Shape();			line1.graphics.lineStyle(3, 0xFFFFFF);			line1.graphics.lineTo(format.buttonSize/3, format.buttonSize/3);			line1.x = btnBgr.width/2 - line1.width/2 + 1;			line1.y = btnBgr.height/2 - line1.height/2 + 1;			var line2:Shape = new Shape();			line2.graphics.lineStyle(3, 0xFFFFFF);			line2.graphics.moveTo(format.buttonSize/3, 0);			line2.graphics.lineTo(0, format.buttonSize/3);			line2.x = btnBgr.width/2 - line2.width/2 + 1;			line2.y = btnBgr.height/2 - line2.height/2 + 1;			btn.addChild(btnBgr);			btn.addChild(line1);			btn.addChild(line2);			btn.buttonMode = true;			return btn;		}				/**  Sets values for next and previous buttons. **/		public function setNavIndex(cE:int, tE:int):void		{			trace("LightboxWindow.setNavIndex: "+cE+" of "+tE);			currElement = cE;			totalElements = tE;		}				private function createNavButton():Sprite		{			var btn:Sprite = new Sprite();			var btnBgr:Sprite = new EllipseShape(format.buttonSize, format.buttonSize, format.buttonColor);			var arrowHead:Sprite = new ArrowHead(format.buttonSize/4, format.buttonSize/2, 3, 0xFFFFFF);			arrowHead.x = btnBgr.width/2 - 1;			arrowHead.y = btnBgr.height/2 - arrowHead.height/2 + 1;			btn.addChild(btnBgr);			btn.addChild(arrowHead);			btn.buttonMode = true;			btn.alpha = .9;			btn.addEventListener(MouseEvent.MOUSE_OVER, onOver, false, 0, true);			btn.addEventListener(MouseEvent.MOUSE_OUT, onOut, false, 0, true);			return btn;		}			//--------------------------------------------------------------------------    //    //  Transitions    //    //--------------------------------------------------------------------------			private function transitionIn():void		{			this.visible = true;			switch (transitionStyle)			{				case TRANSITION_BUILD:						transitionInBuild();					break;									case TRANSITION_FLY_IN_RIGHT:						transitionInFlyInRight();					break;									case TRANSITION_FLY_IN_LEFT:						transitionInFlyInLeft();					break;									default:					transitionInBuild();					break;			}		}				private function transitionInBuild():void		{			TweenLite.from(contentBackground, .5, {scaleY:.01, ease:Expo.easeInOut});			TweenLite.from(content, .25, {alpha:0, delay:.5});			TweenLite.from(descriptionText, .25, {alpha:0, delay:.5});			if (prevButton)				TweenLite.from(prevButton, .25, {alpha:0, delay:.75});			if (nextButton)				TweenLite.from(nextButton, .25, {alpha:0, delay:.75});			if (navButtonField)				TweenLite.from(navButtonField, .25, {alpha:0, delay:.75});			TweenLite.from(closeButton, .25, {alpha:0, delay:.75, onComplete:transitionInComplete});		}				private function transitionInFlyInRight():void		{			TweenLite.from(this, .5, {alpha:0, x:this.x + this.width, ease:Expo.easeOut, onComplete:transitionInComplete});		}				private function transitionInFlyInLeft():void		{			TweenLite.from(this, .5, {alpha:0, x:this.x - this.width, ease:Expo.easeOut, onComplete:transitionInComplete});		}				private function transitionInComplete():void		{			dispatchEvent(new Event(Event.COMPLETE));						if (format.enableKeyboardControls)				stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyboard);		}				public function transitionOut():void		{			trace("LightboxWindow.transitionOut");			switch (transitionStyle)			{				case TRANSITION_BUILD:					{					transitionOutBuild();					break;				}								case TRANSITION_FLY_IN_RIGHT:					{					transitionOutFlyInRight();					break;				}								case TRANSITION_FLY_IN_LEFT:					{					transitionOutFlyInLeft();					break;				}								default:				{					transitionOutBuild();					break;				}			}		}				private function transitionOutBuild():void		{			if (content)				TweenLite.to(content, .25, {alpha:0});			if (descriptionText)				TweenLite.to(descriptionText, .25, {alpha:0});			if (closeButton)				TweenLite.to(closeButton, .25, {alpha:0});			if (prevButton)  				TweenLite.to(prevButton, .25, {alpha:0});			if (nextButton)  				TweenLite.to(nextButton, .25, {alpha:0});			if (contentBackground)				TweenLite.to(contentBackground, .25, {scaleY:.01, delay:.1, ease:Expo.easeIn, onComplete:transitionOutComplete});		}				private function transitionOutFlyInRight():void		{			TweenLite.to(this, .25, {alpha:0, x:this.x - this.width, ease:Expo.easeIn, onComplete:transitionOutComplete});		}				private function transitionOutFlyInLeft():void		{			TweenLite.to(this, .25, {alpha:0, x:this.x + this.width, ease:Expo.easeIn, onComplete:transitionOutComplete});		}				private function transitionOutComplete():void		{			trace("LightboxWindow.transitionOutComplete");			destroy();		}				private function enterFullScreenMode():void		{			trace("LightboxWindow.enterFullScreenMode");			content.width = stage.stageWidth;			content.scaleY = content.scaleX;			content.x = -content.width/2;			content.y = -content.height/2;			contentBackground.visible = descriptionText.visible = closeButton.visible = false;			if (nextButton)				nextButton.visible = false;			if (prevButton)				prevButton.visible = false;			if (navButtonField)				navButtonField.visible = false;		}				private function exitFullScreenMode():void		{			trace("LightboxWindow.exitFullScreenMode");			content.scaleY = content.scaleX = 1;			content.x = -content.width/2;			content.y = -content.height/2;			contentBackground.visible = descriptionText.visible = closeButton.visible = true;			if (nextButton)				nextButton.visible = true;			if (prevButton)				prevButton.visible = true;			if (navButtonField)				navButtonField.visible = true;		}				public function destroy():void		{			trace("LightboxWindow.destroy");			clearClickEvents();			content.destroy();			if (parent) 				parent.removeChild(this);		}			//--------------------------------------------------------------------------    //    //  Event Handlers    //    //--------------------------------------------------------------------------				private function onNextClick(event:MouseEvent = null):void		{			dispatchEvent(new Event(LIGHTBOX_NEXT));		}				private function onPrevClick(event:MouseEvent = null):void		{			dispatchEvent(new Event(LIGHTBOX_PREV));		}				private function onKeyboard(event:KeyboardEvent):void		{			trace("onKeyboard: "+event.charCode);			switch (event.keyCode)			{				case Keyboard.RIGHT:					onNextClick();					break;											case Keyboard.LEFT:					onPrevClick();					break;									case 88:					onCloseClick();					break;			} 		}				private function onOver(event:MouseEvent):void		{			event.currentTarget.alpha = 1;		}				private function onOut(event:MouseEvent):void		{			event.currentTarget.alpha = .9;		}				private function onCloseClick(event:Event = null):void		{			dispatchEvent(new Event(Event.CLOSE));		}				private function onFullScreenContent(event:UIEvent):void		{			trace("FULL SCREEN CLICK");			if (event.value == UIEvent.FULL_SCREEN_CONTENT_ENTER)				enterFullScreenMode();			else				exitFullScreenMode();		}				private function clearClickEvents():void		{			if (nextButton)			{				nextButton.removeEventListener(MouseEvent.CLICK, onNextClick);				nextButton.removeEventListener(MouseEvent.CLICK, onOver);				nextButton.removeEventListener(MouseEvent.CLICK, onOut);			}			if (prevButton)			{				prevButton.removeEventListener(MouseEvent.CLICK, onPrevClick);				prevButton.removeEventListener(MouseEvent.CLICK, onOver);				prevButton.removeEventListener(MouseEvent.CLICK, onOut);			}			closeButton.removeEventListener(MouseEvent.CLICK, onCloseClick);			removeEventListener(UIEvent.FULL_SCREEN_CONTENT, onFullScreenContent);		}				private function onContentLoadComplete(event:Event):void		{			content.removeEventListener(Event.COMPLETE, onContentLoadComplete);			content.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);			if (content.width > 0)				build();			else				onIOError(new IOErrorEvent(IOErrorEvent.IO_ERROR));		}				private function onIOError(event:IOErrorEvent):void		{			trace("LightboxWindow Content not found at "+contentInfo.url);			this.visible = false;			dispatchEvent(event);		}	}}