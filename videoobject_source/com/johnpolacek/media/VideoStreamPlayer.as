package com.johnpolacek.media {		import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.display.Loader;	import flash.display.StageDisplayState;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.AsyncErrorEvent;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.events.NetStatusEvent;    import flash.events.SecurityErrorEvent;	import flash.media.SoundTransform;    import flash.media.Video;    import flash.net.NetConnection;    import flash.net.NetStream;	import flash.net.URLRequest;	import flash.utils.Timer;	import com.johnpolacek.display.ImageDisplay;	import com.johnpolacek.events.UIEvent;	import com.johnpolacek.shapes.RectangleShape;	import com.johnpolacek.ui.FullScreenButton;	import com.johnpolacek.ui.ProgressBar;	import com.johnpolacek.ui.PlayPauseButton;	import com.johnpolacek.ui.VolumeControl;	/** * * @example  * <code>import com.johnpolacek.media.VideoStreamPlayer; * var player:AudioPlayer new VideoStreamPlayer(); * player.playVideo("example.flv"); * player.addController();   // adds default controls to player	 * player.addPoster("poster.jpg"); * player.autoRewind = true; * player.autoPlay = false; * addChild(player); * </code> * * * @see com.johnpolacek.ui.ProgressBar * @see com.johnpolacek.ui.PlayPauseButton * @see com.johnpolacek.ui.VolumeControl * * @sends Event.COMPLETE # When load is complete. * @sends UIEvent.PLAYBACK_START # When playback starts. * @sends UIEvent.PLAYBACK_FINISH # When playback finishes. *  * @version  * <b>20 Mar 2010</b> Now dispatches UIEvent.PLAYBACK_START <br> * <b>19 Mar 2010</b> Switched poster and controls objects to public vars. Enlarged controls. <br> * <b>7 Mar 2010</b> * @author John Polacek, john@johnpolacek.com */	 		public class VideoStreamPlayer extends Sprite {				/** Color of player buttons. Default is 0xFFFFFF */		public var buttonColor:uint = 0xFFFFFF;		/** Color of player background. Default is 0x000000 */		public var backgroundColor:uint = 0x000000;		/** Color of player accent color. Default is 0x999999 */		public var accentColor:uint = 0x999999;		/** Default is false */		public var autoPlay:Boolean = false;		/** Default is true */		public var autoRewind:Boolean = true;		/** Optional poster image that displays before video is played */		public var poster:Sprite = new Sprite();		/** Video controls sprite */		public var controls:Sprite = new Sprite();		/** Boolean determines if controller is inside or outside the video. Default is false. */		public var controlsOutside:Boolean = false;		/** Video stream */		public var video:Video;				private var fullScreenButton:FullScreenButton;		private var connection:NetConnection;		private var stream:NetStream;		private var videoData:Object;		private var playControl:PlayPauseButton;		private var progressBar:ProgressBar;		private var fullScreenMode:Boolean = false;		private var volumeControl:VolumeControl;		private var controlsEnabled:Boolean = false;		private var fullScreenEnabled:Boolean = true;		private var isPlaying:Boolean = false;		private var progressTimer:Timer; // timer for updating progress bar during playback				/** Buffer time for the video in seconds. */// 		public static const BUFFER_TIME:Number = 8;		/** Default volume for player. */// 		public static const DEFAULT_VOLUME:Number	= 0.6;		/** Progress update delay in milliseconds. */// 		public static const PROGRESS_TIMER_DELAY:int = 50;						public function VideoStreamPlayer()		{			connection = new NetConnection();			connection.connect(null);			stream = new NetStream(connection);			stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, aSyncErrorHandler, false, 0, true);						var customClient:Object = new Object();			customClient.onMetaData = metaDataHandler;			stream.client = customClient;			stream.bufferTime = BUFFER_TIME;            video = new Video();            video.attachNetStream(stream);			video.smoothing = true;						// configure stage			//			this.visible = false;			addChild(video);			addChild(poster);			addChild(controls);						progressTimer = new Timer(PROGRESS_TIMER_DELAY, 0);			progressTimer.addEventListener(TimerEvent.TIMER, onProgressTimer, false, 0, true);            			// configure event listeners			//			connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler, false, 0, true);			stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler, false, 0, true);			addEventListener(Event.REMOVED_FROM_STAGE, onRemoved, false, 0, true);			poster.addEventListener(MouseEvent.CLICK, onPosterClick, false, 0, true);		}			//--------------------------------------------------------------------------    //    //  CONTROLS    //    //--------------------------------------------------------------------------					/** Loads video from url.		*		* @param url Video url		* @param autoPlay Sets autoPlay boolean		*/		public function loadVideo(url:String, videoAutoPlay:Boolean = false):void		{			autoPlay = videoAutoPlay;			playVideo(url);			if (!autoPlay)				rewindVideo();			autoHideController();		}				/** Starts playback.		*		* @param url Video url (only used when no video is loaded)		*/		public function playVideo(url:String = null):void		{			if (!url) 			{				if (!videoData) 					trace("No video loaded.");				else 					resumeVideo();			}			else			{				stream.play(url);				isPlaying = true;								if (playControl)  					playControl.setPlayState(true);								if (progressBar)					progressTimer.start();			}						poster.visible = false;		}				/** Pauses playback. */		public function pauseVideo():void		{			stream.pause();			if (playControl)  				playControl.setPlayState(false);			progressTimer.stop();			isPlaying = false;		}				/** Resumes playback. */		public function resumeVideo():void		{			stream.resume();						if (playControl)  				playControl.setPlayState(true);						if (progressBar)  				progressTimer.start();						isPlaying = true;			poster.visible = false;		}				/** Returns and pauses playback to start of video. */		public function rewindVideo():void		{			stream.seek(0);			pauseVideo();			poster.visible = true;			if (progressBar)				progressBar.setProgress(0);		}				/** Sets playhead to a percentage of the video's duration.		*		* @param p Percentage of video duration		*/		public function seekVideo(p:Number):void		{			stream.seek(p);			poster.visible = false;		}			//--------------------------------------------------------------------------    //    //  OBJECT CREATION    //    //--------------------------------------------------------------------------					private function initPlayer():void		{			this.visible = true;			video.height = videoData.height;			video.width = videoData.width;			if (controlsEnabled && controls.numChildren == 0) 				createControls();							setControlsPosition();						if (poster.numChildren > 0) 			{				poster.width = videoData.width;				poster.height = videoData.height;			}						dispatchEvent(new Event(Event.COMPLETE));		}				private function setControlsPosition():void		{			if (fullScreenMode) {				controls.x = controls.width/2;				controls.y = video.y + video.height - controls.height;			} else {				controls.x = 0;				controls.y = video.height;								if (!controlsOutside)					controls.y -= controls.height;			}			}				public function addPoster(filepath:String):void		{			var image:ImageDisplay = new ImageDisplay(filepath);			poster.addChild(image);			poster.buttonMode = true;		}				public function addController():void		{			controlsEnabled = true;		}				public function createControls():void		{			var bgr:Sprite = new RectangleShape(videoData.width, 30, backgroundColor);			var shine:Sprite = new RectangleShape(videoData.width, 15, buttonColor, .1);						playControl = new PlayPauseButton(30, 30, backgroundColor, buttonColor);						volumeControl = new VolumeControl(80, 30, backgroundColor, buttonColor);			volumeControl.x = video.width - volumeControl.width;						fullScreenButton = new FullScreenButton(30, 30, backgroundColor, buttonColor);			fullScreenButton.x = volumeControl.x - fullScreenButton.width;			fullScreenButton.visible = fullScreenEnabled;						progressBar = new ProgressBar(video.width - playControl.width - volumeControl.width - fullScreenButton.width - 30, 6, backgroundColor, buttonColor, accentColor);			progressBar.x = playControl.width + 15;			progressBar.y = (bgr.height - progressBar.height) / 2;			progressBar.setProgress(0);						controls.addChild(bgr);			controls.addChild(playControl);			controls.addChild(progressBar);			controls.addChild(volumeControl);			controls.addChild(fullScreenButton);						progressBar.addEventListener(UIEvent.PROGRESS_UPDATE, onProgressBarUpdate, false, 0, true);			playControl.addEventListener(UIEvent.PLAY_CLICK, onPlayClick, false, 0, true);			playControl.addEventListener(UIEvent.PAUSE_CLICK, onPauseClick, false, 0, true);			volumeControl.addEventListener(UIEvent.VOLUME_ADJUST, onVolumeAdjust, false, 0, true);			fullScreenButton.addEventListener(MouseEvent.CLICK, onFullScreenClick);			volumeControl.setVolume(DEFAULT_VOLUME);			if (isPlaying) 				progressTimer.start();			playControl.setPlayState(isPlaying);		}				/** Moves controller inside the video player and hides on MOUSE_OUT **/		public function autoHideController():void		{			controlsOutside = false;			controls.y = video.height - controls.height;			addEventListener(MouseEvent.MOUSE_OVER, showControls);			addEventListener(MouseEvent.MOUSE_OUT, hideControls);			if (autoPlay)				controls.alpha = 0;		}				public function destroy():void		{			stream.pause();			progressBar.removeEventListener(UIEvent.PROGRESS_UPDATE, onProgressBarUpdate);			playControl.removeEventListener(UIEvent.PLAY_CLICK, onPlayClick);			playControl.removeEventListener(UIEvent.PAUSE_CLICK, onPauseClick);			volumeControl.removeEventListener(UIEvent.VOLUME_ADJUST, onVolumeAdjust);			stream.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, aSyncErrorHandler);			removeEventListener(MouseEvent.MOUSE_OVER, showControls);			removeEventListener(MouseEvent.MOUSE_OUT, hideControls);			connection.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);			stream.removeEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);			removeEventListener(Event.REMOVED_FROM_STAGE, onRemoved);			poster.removeEventListener(MouseEvent.CLICK, onPosterClick);			fullScreenButton.removeEventListener(MouseEvent.CLICK, onFullScreenClick);		}			//--------------------------------------------------------------------------    //    //  EVENTS HANDLERS    //    //--------------------------------------------------------------------------				private function netStatusHandler(event:NetStatusEvent):void 		{			if (event.info.code.toString() == "NetStream.Play.Start" && autoPlay) 				dispatchEvent(new UIEvent(UIEvent.PLAYBACK_START));			if (event.info.code.toString() == "NetStream.Play.Stop")  				onVideoFinish();			if (event.info.code.toString() == "NetStream.Play.StreamNotFound")  				dispatchEvent(new IOErrorEvent(IOErrorEvent.IO_ERROR, false, false, "Video Stream not found"));        }        private function securityErrorHandler(event:SecurityErrorEvent):void 		{            trace("VideoStreamPlayer securityErrorHandler: " + event);        }        private function metaDataHandler(data:Object):void 		{           if (data)			{				videoData = data;				initPlayer();			}        }				private function aSyncErrorHandler(event:AsyncErrorEvent):void		{			trace(event.text);		}				private function onRemoved(event:Event):void		{			stream.close();		}				public function onVideoFinish():void		{			if (autoRewind)				rewindVideo();			if (fullScreenMode)				toggleFullScreenMode();			dispatchEvent(new UIEvent(UIEvent.PLAYBACK_FINISH));		}				private function onPlayClick(event:UIEvent = null):void		{			dispatchEvent(new UIEvent(UIEvent.PLAYBACK_START));			resumeVideo();		}				private function onPauseClick(event:UIEvent = null):void		{			pauseVideo();		}				private function onFullScreenClick(event:MouseEvent):void		{			toggleFullScreenMode();		}				private function toggleFullScreenMode():void		{			fullScreenButton.toggleFullScreenState();			fullScreenMode = !fullScreenMode;						if (fullScreenMode) {				dispatchEvent(new UIEvent(UIEvent.FULL_SCREEN_CONTENT, UIEvent.FULL_SCREEN_CONTENT_ENTER));				video.addEventListener(MouseEvent.CLICK, onFullScreenClick);				seekVideo(0);				if (!isPlaying)					onPlayClick();				controls.scaleX = controls.scaleY = 1/(stage.stageWidth/video.width);						} else {				controls.scaleX = controls.scaleY = 1;				dispatchEvent(new UIEvent(UIEvent.FULL_SCREEN_CONTENT, UIEvent.FULL_SCREEN_CONTENT_EXIT));				video.removeEventListener(MouseEvent.CLICK, onFullScreenClick);			}						setControlsPosition();		}				private function onPosterClick(event:MouseEvent):void		{			if(videoData) 				playVideo();		}				private function onVideoClick(event:MouseEvent):void		{			if(isPlaying) 				onPauseClick();			else				onPlayClick();		}				private function showControls(event:MouseEvent):void		{			controls.alpha = 1;		}				private function hideControls(event:MouseEvent):void		{			controls.alpha = 0;		}				private function onProgressBarUpdate(event:UIEvent):void		{			seekVideo(event.value * videoData.duration);		}		private function onProgressTimer(event:TimerEvent):void		{			if (videoData)  			{				var p:Number = stream.time / videoData.duration;				progressBar.setProgress(stream.time / videoData.duration);			}		}				private function onVolumeAdjust(event:UIEvent):void		{			var transform:SoundTransform = stream.soundTransform;			transform.volume = event.value;			stream.soundTransform = transform;		}				public function enableFullScreen(enable:Boolean):void {			if (fullScreenButton)				fullScreenButton.visible = enable;			fullScreenEnabled = enable;		}		}}